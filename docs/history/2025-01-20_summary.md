# 2025-01-20 – Dev Session Summary (Bounty Hunter)

## 1. High-level outcome

Today's session focused on stabilizing the core user flows and fixing critical mobile UI issues:

- **Onboarding flow is stable**: New users can sign up via magic link, complete onboarding without infinite loading or redirect loops, and are correctly routed through the 4-step wizard.
- **Auth callback handling fixed**: Magic link login no longer shows blank screens; `/login` properly handles Supabase auth callbacks and redirects authenticated users.
- **Profile bootstrap is robust**: `ensureProfileForUser` always resolves (returns `Profile | null`), never hangs, and handles errors gracefully without blocking onboarding.
- **Domain layer remains intact**: No regressions to existing domain functions (`src/domain/*`); onboarding-specific changes were additive.
- **Mobile modals are consistent**: All modals (TaskForm, ProofModal, TaskCard expanded) now use portals to `#overlay-root` with centralized scroll locking.
- **Scroll locking is predictable**: Background scroll is locked when `activeLayer === 'modal'` via `UIContext`; modal content scrolls independently with `overscroll-behavior: contain`.
- **Pull-to-refresh is gated**: `PullToRefresh` components conditionally render only when `activeLayer !== 'modal'` to prevent gesture conflicts.
- **Mobile hamburger menu works deterministically**: Menu opens/closes only via explicit user actions (backdrop click, close button, nav link); no more auto-close glitches.
- **Runtime errors fixed**: Resolved `ReferenceError: activeLayer is not defined` and `ReferenceError: setIsMobileMenuOpen is not defined` that were causing crashes.

---

## 2. Auth & Onboarding fixes

### 2.1 Login page / magic link callback (`src/pages/Login.tsx`)

**Problem**: New users clicking magic links saw blank screens because `<Navigate>` redirected before Supabase finished processing the auth callback.

**Solution**:
- Replaced `<Navigate>` with `useEffect` + `useNavigate` that only redirects after `authLoading === false` and `user && session` exist.
- Added explicit loading states: "Loading..." while `authLoading === true`, "Signing you in..." when authenticated but redirect pending.
- Updated redirect URLs to explicitly point to `/login` for both magic link and Google OAuth callbacks.

**Key changes**:
```typescript
// Before: Immediate redirect via <Navigate>
if (user) return <Navigate to="/" replace />;

// After: Effect-based redirect after auth initialization
useEffect(() => {
  if (!authLoading && user && session) {
    navigate('/', { replace: true });
  }
}, [user, session, authLoading, navigate]);
```

### 2.2 useAuth hook (`src/hooks/useAuth.ts`)

**Problem**: Profile loading was conflated with session loading, causing infinite loading screens. `ensureProfile` was called multiple times without guards.

**Solution**:
- Separated `authLoading` (Supabase session initialization) from `profileLoading` (profile fetching).
- Added `ensuringUserIdRef` to prevent duplicate `ensureProfile` calls for the same user.
- Split effects: one for session initialization/listener, another for profile ensuring (depends only on `session`).
- Exported explicit flags: `hasSession = !!session`, `hasProfile = !!profile`.

**Key structure**:
```typescript
// Effect 1: Session initialization
useEffect(() => {
  // Initialize session, set up auth state listener
  // Sets authLoading to false when done
}, []);

// Effect 2: Profile ensuring (depends only on session)
useEffect(() => {
  if (!session?.user) {
    setProfile(null);
    setProfileLoading(false);
    return;
  }
  
  // Guard against duplicate calls
  if (ensuringUserIdRef.current === session.user.id) return;
  
  // Ensure profile once per session change
  ensureProfile();
}, [session]);
```

### 2.3 Profile bootstrap (`src/lib/profileBootstrap.ts`)

**Problem**: `ensureProfileForUser` could hang or throw unhandled errors, leaving `profileLoading` stuck at `true`.

**Solution**:
- Changed return type to `Promise<Profile | null>` (never throws).
- Wrapped entire logic in `try/catch`; returns `null` on any error.
- Uses `.maybeSingle()` for selects (returns `null` data when no rows found, not an error).
- Added detailed logging for debugging each step.
- Always resolves: either returns a `Profile` object or `null`, never hangs.

**Key pattern**:
```typescript
export async function ensureProfileForUser(
  supabase: SupabaseClient,
  user: User
): Promise<Profile | null> {
  try {
    // 1. Try to load existing profile
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .maybeSingle(); // Returns null data when no row found
    
    if (error) return null; // Real error → return null
    if (profile) return profile; // Found → return it
    
    // 2. Create new profile
    const { data: inserted, error: insertError } = await supabase
      .from('profiles')
      .insert({ ... })
      .select('*')
      .single();
    
    if (insertError || !inserted) return null;
    return inserted;
  } catch (err) {
    return null; // Always resolve, never throw
  }
}
```

### 2.4 Onboarding page (`src/pages/Onboarding.tsx`)

**Problem**: Onboarding was blocked by `profileLoading`, showing "Loading your profile..." forever. Logic re-derived `hasSession`/`hasProfile` instead of using `useAuth` flags.

**Solution**:
- Removed blocking `if (profileLoading)` gate; wizard renders as soon as `hasSession === true`.
- Uses explicit `hasSession` and `hasProfile` flags from `useAuth` (no re-derivation).
- Profile is treated as optional for prefilling; onboarding proceeds even if `hasProfile === false`.
- Removed "Loading your profile..." text from Steps 2–4 (profile loading is background-only).

**Gating logic**:
```typescript
// 1. While auth is initializing
if (authLoading) return <LoadingScreen />;

// 2. No session → redirect to login
if (!hasSession) return <Navigate to="/login" replace />;

// 3. Render wizard (profile loading continues in background, non-blocking)
return <OnboardingWizard ... />;
```

### 2.5 ProtectedRoute (`src/App.tsx`)

**Change**: Simplified to only handle authentication, not profile loading.

- Before: Blocked on `profileLoading`, causing infinite loading.
- After: Only blocks on `authLoading`; profile loading is handled by individual components.

---

## 3. Domain & RLS changes relevant to onboarding

### 3.1 RLS and schema changes for unassigned rewards

**Migration**: `supabase/migrations/20250128000000_allow_unassigned_rewards_for_onboarding.sql`

**Changes**:
1. Made `rewards_store.assigned_to` nullable:
   ```sql
   ALTER TABLE public.rewards_store 
     ALTER COLUMN assigned_to DROP NOT NULL;
   ```

2. Added RLS policy for onboarding:
   ```sql
   CREATE POLICY "Create unassigned rewards for onboarding"
   ON public.rewards_store FOR INSERT
   TO authenticated
   WITH CHECK (
     creator_id = auth.uid() 
     AND assigned_to IS NULL
   );
   ```

**Rationale**: Onboarding Step 2 allows users to create a reward without having friends/partners yet. The existing RPC `create_reward_store_item` requires a friendship, so we bypass it during onboarding and insert directly with `assigned_to = NULL`.

### 3.2 Domain layer behavior (`src/domain/rewards.ts`)

**Change**: `createReward` function now accepts `isOnboarding?: boolean` parameter.

**Behavior**:
- **Normal flow** (`isOnboarding === false`): Uses RPC `create_reward_store_item` (requires friendship).
- **Onboarding flow** (`isOnboarding === true`): Directly inserts into `rewards_store` with `assigned_to: null`, bypassing RPC friendship check.

**Error handling**: Onboarding errors return `{ success: false, message: string }` instead of throwing, allowing users to proceed (they can skip Step 2 or create rewards later).

**Key code**:
```typescript
export async function createReward(params: CreateRewardParams): Promise<CreateRewardResult> {
  const { isOnboarding = false, ... } = params;
  
  if (isOnboarding) {
    // Direct insert for onboarding (no friendship required)
    const { data: inserted, error: insertError } = await supabaseClient
      .from('rewards_store')
      .insert({
        name: rewardData.p_name,
        creator_id: userId,
        assigned_to: null, // Unassigned during onboarding
      })
      .select('id')
      .single();
    
    if (insertError) {
      return { success: false, message: 'Couldn\'t save this gift right now...' };
    }
    return { success: true, reward_id: inserted.id, ... };
  }
  
  // Normal RPC flow (requires friendship)
  // ...
}
```

### 3.3 Onboarding Step 2 (`src/components/onboarding/OnboardingStep2Reward.tsx`)

**Change**: Calls `createReward` with `isOnboarding: true` and `p_assigned_to: null`.

- Error handling is non-blocking: shows toast but doesn't prevent progression.
- "Skip for now" button works correctly (no API calls, just advances to Step 3).

### 3.4 Onboarding Step 4 (`src/components/onboarding/OnboardingStep4Mission.tsx`)

**Change**: Improved helper text for "Assign To" dropdown when no friends available:
- Before: Generic placeholder text.
- After: "Only you for now (invite someone later to assign missions to them)."

---

## 4. Couple Mode & Partner System

**Note**: This section documents the current state after today's changes. The partner system was implemented in a previous session but remains stable.

### 4.1 usePartnerState hook (`src/hooks/usePartnerState.ts`)

**Purpose**: Manages relationship state for Couple Mode by reading from `friendships` table.

**States**:
- `NO_PARTNER`: No friendship exists.
- `INVITE_SENT`: User has sent an invite (pending).
- `INVITE_RECEIVED`: User has received an invite (can accept/decline).
- `PARTNERED`: Active friendship exists.

**Behavior**:
- Subscribes to real-time updates on `friendships` table.
- Returns `partnerProfile`, `friendshipId`, `isLoading`, `error`, and `refresh()` function.

### 4.2 Friends / Partner page (`src/pages/Friends.tsx`)

**Behavior**:
- **Couple Mode**: Shows partner-specific UI based on `usePartnerState`:
  - `NO_PARTNER`: "Invite your partner" CTA.
  - `INVITE_SENT`: Shows message + "Cancel invite" button.
  - `INVITE_RECEIVED`: Shows inviter's profile + "Accept"/"Decline" buttons.
  - `PARTNERED`: Shows both users' avatars, names, and CTAs for "Create request" and "Create gift".
- **Guild/Family Modes**: Shows generic friends list, search, and request tabs.

---

## 5. Mobile modals & overlay architecture

### 5.1 TaskForm modal portal (`src/components/TaskForm.tsx`)

**Problem**: TaskForm rendered directly in component tree, causing iOS stacking context issues where header overlapped modals and clicks were intercepted.

**Solution**: Wrapped modal content in `createPortal` targeting `#overlay-root`.

**Key changes**:
- Modal content now renders to `#overlay-root` (defined in `src/index.html`).
- Added `data-overlay="TaskForm"` attribute for debugging.
- Modal structure: backdrop (`fixed inset-0`) + content panel (scrollable with `overscroll-behavior: contain`).

**Code pattern**:
```typescript
const overlayRoot = getOverlayRoot(); // Returns document.getElementById('overlay-root')
if (!overlayRoot) return null;

return createPortal(
  <div data-overlay="TaskForm" className="fixed inset-0 ...">
    {/* Modal content */}
  </div>,
  overlayRoot
);
```

### 5.2 Scroll lock centralization (`src/lib/scrollLock.ts`, `src/context/UIContext.tsx`)

**Problem**: Multiple components manually set `document.body.style.overflow`, causing conflicts and race conditions.

**Solution**: Centralized scroll locking in `UIContext` based on `activeLayer`.

**Implementation**:
- `UIContext` effect watches `activeLayer`:
  ```typescript
  useEffect(() => {
    if (activeLayer !== 'none') {
      lockScroll();
    } else {
      unlockScroll();
    }
  }, [activeLayer]);
  ```

- `lockScroll()` applies:
  - `overflow: hidden` on `body` and `html`
  - `position: fixed` + `width: 100%` (prevents iOS bounce)
  - `overscroll-behavior: none` (prevents pull-to-refresh)
  - `touch-action: none` (prevents touch gestures on background)

- Modal content uses `overscroll-behavior: contain` and `touch-action: pan-y` to allow scrolling only inside the modal.

**Removed**: Manual scroll lock from `TaskCard.tsx` (was conflicting with `UIContext`).

### 5.3 PullToRefresh integration (`src/pages/IssuedPage.tsx`, `src/pages/Dashboard.tsx`)

**Problem**: Pull-to-refresh could fire while modals were open, causing modals to flicker or close unexpectedly.

**Solution**: Conditionally render `PullToRefresh` only when `activeLayer !== 'modal'`.

**Pattern**:
```typescript
const { activeLayer } = useUI();

return (
  <>
    {/* Modals render outside PullToRefresh */}
    {isTaskFormOpen && <TaskForm ... />}
    
    {/* PullToRefresh only when no modal is open */}
    {activeLayer === 'modal' ? (
      <PageContainer>{/* Content without PullToRefresh */}</PageContainer>
    ) : (
      <PullToRefresh onRefresh={handleRefresh}>
        <PageContainer>{/* Content */}</PageContainer>
      </PullToRefresh>
    )}
  </>
);
```

### 5.4 OverlayDebug instrumentation (`src/lib/overlayDebug.ts`)

**Purpose**: Debug helper to identify "zombie overlays" in `#overlay-root`.

**Function**: `logOverlayRootState(label: string)`
- Logs all children of `#overlay-root` with their `data-overlay` attributes, z-index, pointer-events, display, visibility.
- Only runs in dev mode (`import.meta.env.DEV`).
- Used to confirm `#overlay-root` was empty during "glitchy" states.

**Usage**: Called from `UIContext` when `activeLayer` changes, and from hamburger click handler in `Layout.tsx`.

**Note**: Can be removed later once we're confident the overlay system is stable.

---

## 6. Mobile menu (hamburger) debugging and final behavior

### 6.1 Initial issues

**Symptom**: Hamburger button appeared to "do nothing" or menu would "open and instantly close."

**Root causes found**:
1. **Missing variable reference**: `activeLayer` was used in `Layout.tsx` hamburger click handler without being destructured from `useUI()` → `ReferenceError: activeLayer is not defined`.
2. **Global click handlers**: Layout had click handlers that auto-closed menu on any click (including hamburger click).
3. **State setter mismatch**: State declared as `[isMobileMenuOpen, setMobileMenuOpen]` but code used `setIsMobileMenuOpen` → `ReferenceError: setIsMobileMenuOpen is not defined`.
4. **clearLayer calling non-existent setter**: `clearLayer()` called `setIsMobileMenuOpen(false)` which didn't exist → crash when ProfileEditModal mounted.

### 6.2 Final refactor (Phase UX-2)

**UIContext API** (`src/context/UIContext.tsx`):
- Exposes: `isMobileMenuOpen`, `openMenu()`, `closeMenu()`, `toggleMenu()`, `activeLayer`.
- All menu functions use `useCallback` for stability.
- `forceCloseMobileMenu()` is a thin alias of `closeMenu()` (kept for backward compatibility).
- `clearLayer()` only resets `activeLayer` to `'none'`; does not touch menu state directly.

**Menu functions**:
```typescript
const openMenu = useCallback(() => {
  setIsMobileMenuOpen(true);
  setActiveLayer('menu');
}, []);

const closeMenu = useCallback(() => {
  setIsMobileMenuOpen(false);
  setActiveLayer('none');
}, []);

const toggleMenu = useCallback(() => {
  setIsMobileMenuOpen((prev) => {
    const next = !prev;
    setActiveLayer(next ? 'menu' : 'none');
    return next;
  });
}, [isMobileMenuOpen]);
```

**Layout.tsx structure** (`src/components/Layout.tsx`):
- Hamburger button: Simple `onClick={() => toggleMenu()}` (no `preventDefault` or gymnastics).
- Mobile menu render:
  ```typescript
  {isMobileMenuOpen && (
    <div className="fixed inset-0 z-[var(--z-mobile-menu)]">
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/60"
        onClick={() => closeMenu()}
      />
      {/* Menu panel */}
      <div onClick={(e) => e.stopPropagation()}>
        {/* Close button */}
        <button onClick={() => closeMenu()}>✕</button>
        {/* Nav links */}
        <Link onClick={() => closeMenu()}>...</Link>
      </div>
    </div>
  )}
  ```
- **Removed**: Global click handlers that auto-closed menu on any click.
- **Route change effect**: Only closes menu when `pathname` actually changes (not on same render).

### 6.3 Before vs after

**Before**:
- Hamburger click → menu opens → global click handler fires → menu closes immediately.
- `clearLayer()` crashes app when called (non-existent setter).
- Menu state inconsistent due to multiple sources of truth.

**After**:
- Hamburger click → `toggleMenu()` → menu opens and stays open.
- Menu closes only via explicit actions: backdrop click, close button, nav link click, route change.
- `clearLayer()` only clears `activeLayer`; menu state managed via `closeMenu()`.
- No runtime errors; menu behavior is deterministic.

---

## 7. Known issues / next steps

### 7.1 Known UX issues (non-critical)

- **Terminology inconsistencies**: Mix of "request", "mission", "moment" across UI. Should align with theme strings.
- **Copy cleanup needed**: Some duplicate onboarding copy (e.g., "Create your first mission" appears multiple times).
- **Debug logging**: `OverlayDebug` and `UIContext` logs are verbose in dev mode; can be cleaned up once stable.

### 7.2 Concrete next steps

1. **UI/visual refresh**: Onboarding wizard and dashboard could use visual polish.
2. **Theme polish**: Ensure all empty states, section titles, and CTAs consistently use theme strings across Couple/Guild/Family modes.
3. **Error boundaries**: Add React error boundaries around Supabase network errors to prevent full app crashes.
4. **Profile edit**: Verify avatar and display name saving works correctly (was fixed today but worth re-testing).
5. **Mobile menu polish**: Backdrop tap handling could be more responsive; scroll inside menu could feel more natural.

### 7.3 Architecture notes

- **Domain layer**: Remains stable; no regressions. All mutations go through `src/domain/*`.
- **Overlay system**: Current architecture (portals + `activeLayer` + centralized scroll lock) is working well. Consider documenting as a pattern for future modals.
- **Auth flow**: Magic link + FTXGate + onboarding is now stable. Can be used as reference for future auth-related work.

---

## Files changed (summary)

### Core auth & onboarding
- `src/hooks/useAuth.ts` - Separated auth/profile loading, added guards, explicit flags
- `src/lib/profileBootstrap.ts` - Made robust (always resolves, never throws)
- `src/pages/Login.tsx` - Fixed callback handling, effect-based redirects
- `src/pages/Onboarding.tsx` - Simplified gating, decoupled from profile loading
- `src/App.tsx` - Simplified `ProtectedRoute` (auth only)

### Domain & RLS
- `src/domain/rewards.ts` - Added `isOnboarding` flag for unassigned rewards
- `supabase/migrations/20250128000000_allow_unassigned_rewards_for_onboarding.sql` - Made `assigned_to` nullable, added RLS policy
- `src/components/onboarding/OnboardingStep2Reward.tsx` - Uses onboarding flow
- `src/components/onboarding/OnboardingStep4Mission.tsx` - Improved helper text

### Mobile modals & overlays
- `src/components/TaskForm.tsx` - Portaled to `#overlay-root`
- `src/components/TaskCard.tsx` - Removed manual scroll lock, added portal attributes
- `src/components/ProofModal.tsx` - Added scroll container styles
- `src/lib/scrollLock.ts` - Enhanced with `overscroll-behavior` and `touch-action`
- `src/lib/overlayDebug.ts` - New debug helper for overlay root inspection
- `src/pages/IssuedPage.tsx` - Conditional `PullToRefresh` rendering
- `src/pages/Dashboard.tsx` - Conditional `PullToRefresh` rendering

### Mobile menu
- `src/context/UIContext.tsx` - Refactored menu API, fixed state setter name, simplified `clearLayer`
- `src/components/Layout.tsx` - Removed global click handlers, explicit close paths, fixed variable references

---

**End of session summary**

